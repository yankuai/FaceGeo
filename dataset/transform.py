import numpy as np
import cv2
from torchvision.transforms import functional as F
import torch


def crop_img(img, crop_size, h_offset, w_offset):
    '''crop an image
    Args:
        img: np.array or tensor image in shape (H,W,C)
        crop_size: tuple (crop_w, crop_h) or scalr (assuming square crop)
        h_offset, w_offset: scalars generated by get_random_crop_offsets()
    Returns:
        cropped image
    '''

    dim = len(img.shape)

    if isinstance(crop_size, tuple):
        crop_width = crop_size[0]
        crop_height = crop_size[1]
    else:
        crop_width = crop_height = crop_size

    if dim == 3:
        return img[h_offset: h_offset+crop_height,
                   w_offset: w_offset+crop_width, :]
    elif dim == 2:
        return img[h_offset: h_offset+crop_height,
                   w_offset: w_offset+crop_width]


class Resize(object):
    """Convert ndarrays in sample to Tensors."""
    def __init__(self, shape):
        assert isinstance(shape, (tuple, list))
        self.shape = shape
    def __call__(self, sample):
        image = sample
        return cv2.resize(image, self.shape) # (w, h)

# -----------------------------------------------------------------------------

class ToTensor(object):
    """Convert ndarrays in sample to Tensors."""
    def __call__(self, sample):
        image = sample

        return F.to_tensor(image)

# -----------------------------------------------------------------------------

class Normalize(object):
    def __init__(self, mean, std):
        self.mean = mean
        self.std = std

    def __call__(self, sample):
        if sample.shape[0] > 3:
            image, other = sample[:3], sample[3:]
            image = F.normalize(image, mean=self.mean, std=self.std)
            return torch.cat((image, other), dim=0)
        else:
            return F.normalize(sample, mean=self.mean, std=self.std)
